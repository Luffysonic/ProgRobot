#pragma config(Sensor, S1,     tactileAv,      sensorTouch)
#pragma config(Sensor, S2,     tactileAr,      sensorTouch)
#pragma config(Sensor, S3,     captLumi,       sensorLightActive)
#pragma config(Sensor, S4,     ultraSon,       sensorSONAR)
#pragma config(Motor,  motorA,          mPince,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mDroit,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mGauche,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard
#define dist_ultra 100
#define DiamRoue 56
#define entraxe 114
#define gauche -1
#define droite 1
#define avant 1
#define arriere -1
#define Dist_pos_ZB1 5 //5 Centimetre
#define dist_ultra_J1 40 //Distance entre le Joueur 1
#define dist_ultra_J2 20 //Distance entre le Joueur 1


//----------------------- Sous Programme -----------------//
int calculSeuil(){
	int Couleur1, Couleur2;
	nxtDisplayStringAt(10, 40, "Couleur 1 ?");
	while (nNxtButtonPressed!=kEnterButton)
		{}
	Couleur1 = SensorValue(captLumi);
	wait1Msec(1000);
	nxtDisplayStringAt(10, 40, "Couleur 2 ?");
	while (nNxtButtonPressed!=kEnterButton)
		{}
	Couleur2=SensorValue(captLumi);
	return ((Couleur1+Couleur2)/2);
}


void ouvrirPince(int deg,int puissance) {

	nMotorEncoder[mPince]=0;
	motor[mPince]=puissance;
	while (nMotorEncoder[mPince]<deg)
		{}
	motor[mPince]=0;
}


void fermerPince(int deg,int puissance) {

	nMotorEncoder[mPince]=0;
	motor[mPince]=(-1)*puissance;
	while (nMotorEncoder[mPince]*(-1)<deg)
		{}
	motor[mPince]=0;
}


void tourner2roues(int direction, float angle, int puissance){
	float nbDeg;
	nbDeg=(entraxe*angle)/DiamRoue;
	nMotorEncoder[mDroit]=0;
	nMotorEncoder[mGauche]=0;

  if (direction==droite){
  	motor[mDroit]=puissance*arriere;
  	motor[mGauche]=puissance*avant;
  	while (nMotorEncoder[mGauche]<nbDeg)
  		{}
  	motor[mDroit]=0;
  	motor[mGauche]=0;
	}

	if (direction==gauche){
  	motor[mDroit]=puissance*avant;
  	motor[mGauche]=puissance*arriere;
  	while (nMotorEncoder[mDroit]<nbDeg)
  		{}
  	motor[mDroit]=0;
  	motor[mGauche]=0;
	}
}


void avancerDistance(int sens,float distance,int puissance){
	float dist;
	dist=(distance*sens*10*360)/(PI*DiamRoue);
	nMotorEncoder[mDroit]=0;
	motor[mDroit]=puissance;
  motor[mGauche]=puissance;
  while (nMotorEncoder[mDroit]<dist)
  	{}
	motor[mDroit]=0;
  motor[mGauche]=0;
}

void avancerJusquaSeuil(int puissance ,int seuil){
	motor[mDroit]=puissance;
  motor[mGauche]=puissance;
  while(SensorValue(captLumi) > seuil)
  	{}
	motor[mDroit]=0;
  motor[mGauche]=0;
}

void avancer_detection_Joueur(int puissance,int dist_utra){
	// Le robot avance jusqu'a la detection d'un joueur
	motor[mDroit]=puissance;
	motor[mGauche]=puissance;
	while(SensorValue(ultraSon)>dist_ultra)
		{}
	motor[mDroit]=0;
	motor[mGauche]=0;
}


int detection_autre_defenseur(int dist_utra){
	int posjoueur;
	// Le robot essaye de detecter si le Joueur 2 est a sa gauche ou a sa droite
	tourner2roues(gauche,20,10);
  if (SensorValue(ultraSon)<dist_ultra){
  	posjoueur=gauche;
  }
  wait1Msec(1000);
  tourner2roues(droite,40,10);
  //il doit aussi regarder a droite analogie quand tu es en voiture tu regardes a gauche et a droite
  if (SensorValue(ultraSon)<dist_ultra){
  	posjoueur=droite;
  }
  wait1Msec(1000);
  tourner2roues(gauche,20,10);

	return(posjoueur);
}

void chistera (){
	tourner2roues(gauche,180,30);
	ouvrirPince(30,30);
	avancerDistance(arriere,5,30);
	tourner2roues(droite,180,30);
}

void Cadrage_debordement(int pos_J2){
	if (pos_J2==gauche){
		tourner2roues(gauche,10,10);
		wait1Msec(1000);
		avancerDistance(avant,5,20);
		wait1Msec(1000);
		avancerDistance(arriere,5,20);
		wait1Msec(1000);
		tourner2roues(droite,20,10);
	}
	else{
		tourner2roues(droite,10,10);
		wait1Msec(1000);
		avancerDistance(avant,5,20);
		wait1Msec(1000);
		avancerDistance(arriere,5,20);
		wait1Msec(1000);
		tourner2roues(gauche,20,10);
}

//------------------------Algo Principal----------------------//
// zone ballon en marron//
// Pour l'algo tous les wait1Mec ne sont pas tous a mettre ici je les ai mis pour eviter que le robot patine sur la planche
task main(){
	int SeuilBlancNoir,SeuilBlancBleu,SeuilBlancMarron;
	int pos_def2;
	SeuilBlancBleu=calculSeuil();
	wait1Msec(3000);
	SeuilBlancMarron=calculSeuil();
	wait1Msec(2000);
	//Je fais un marron car les zones ballons//
	SeuilBlancNoir=calculSeuil();
	wait1Msec(3000);
	ouvrirPince(30,30);
	// il ouvre direct pour etre pret a pousser les cannettes en debut

	avancerJusquaLigne(30,SeuilBlancNoir);
	//Il les poussent jusque la 1ere ligne des 22m//
	wait1Msec(1000);
	avancerDistance(arriere,Dist_pos_ZB1,30);
	wait1Msec(1000);
	tourner2roues(gauche,90,10);
	wait1Msec(1000);
	//il se dirige vers la zone ballon 1
	avancerJusquaLigne(30,SeuilBlancMarron);
	// j'attends 5 sec car je pense que c'est nous qui donnons le ballon et comme on peut pas le toucher
	wait1Msec(5000);
	fermerPince(30,30);
	tourner2roues(droite,120,15);
	wait1Msec(1000);
	avancer_detection_Joueur(30,dist_ultra_J1);

	//Le robot doit faire attention a son environnement//
	pos_def2=detection_autre_defenseur(60);
	// le 75 c'est pour la dectection en ultrason
	Cadrage_debordement(pos_def2);
	// Il fait un cadrage et un debordement en fonction de la position du Joueur 2
	avancer_detection_Joueur(30,dist_ultra_J3);
	// il avance jusqu'a la detection du J3 ou du defenseur num 3
	wait1Msec(1000);
	ouvrirPince(30,30);
	// Il ouvre et ferme la pince pour "pousser le joueur" cf Raffut sur le PDF//
	wait1Msec(1000);
	fermerPince(30,30);


	//apres le raffut du Joueur 3 j'essaye de le positionner en face de la zone ballon 2//
	if (pos_2==gauche){
		tourner2roues(gauche,45,10);
		avancerDistance(avant,10,30);
		tourner2roues(droite,90,10);
	}
	else{
		tourner2roues(droite,45,10);
		avancerDistance(avant,10,30);
		tourner2roues(gauche,90,10);
	}
	chistera();

	avancerJusquaLigne(30,SeuilBlancNoir);
	wait1Msec(5000);
	fermerPince(30,30);
	avancerJusquaLigne(30,SeuilBlancMarron);
	// J'image que quand on atteint la fin de la zone ballon les ponces sont au niveaux de la ligne de drop
	wait1Msec(1000);
	ouvrirPince(30,30);
	avancerDistance(arriere,10,30);
	// il recule pour prendre de l'"elan"
	fermerPince(30,30);
	avancerJusquaLigne(30,SeuilBlancBleu);
	// normalement fin du jeu la balle est entre les poteaux








}
