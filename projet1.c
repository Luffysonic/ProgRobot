#pragma config(Sensor, S1,     tactileAv,      sensorTouch)
#pragma config(Sensor, S2,     tactileAr,      sensorTouch)
#pragma config(Sensor, S3,     captLumi,       sensorLightActive)
#pragma config(Sensor, S4,     ultraSon,       sensorSONAR)
#pragma config(Motor,  motorA,          mPince,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mDroit,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mGauche,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard

//- Khaos Ricky (Groupe A) / Michelix Quentin (Groupe C) -//


#define dist_ultra 100
#define DiamRoue 56
#define entraxe 114
#define gauche -1
#define droite 1
#define avant 1
#define arriere -1

//----------------------- Sous Programme -----------------//

int calculSeuil(){
	int Couleur1, Couleur2;
	nxtDisplayStringAt(10, 40, "Couleur 1 ?");
	while (nNxtButtonPressed!=kEnterButton)
		{}
	Couleur1 = SensorValue(captLumi);
	wait1Msec(1000);
	nxtDisplayStringAt(10, 40, "Couleur 2 ?");
	while (nNxtButtonPressed!=kEnterButton)
		{}
	Couleur2=SensorValue(captLumi);
	return ((Couleur1+Couleur2)/2);
}


void ouvrirPince(int deg,int puissance) {

	nMotorEncoder[mPince]=0;
	motor[mPince]=puissance;
	while (nMotorEncoder[mPince]<deg)
		{}
	motor[mPince]=0;
}


void fermerPince(int deg,int puissance) {

	nMotorEncoder[mPince]=0;
	motor[mPince]=(-1)*puissance;
	while (nMotorEncoder[mPince]*(-1)<deg)
		{}
	motor[mPince]=0;
}


void tourner2roues(int direction, float angle, int puissance){
	float nbDeg;
	nbDeg=(entraxe*angle)/DiamRoue;
	nMotorEncoder[mDroit]=0;
	nMotorEncoder[mGauche]=0;

  if (direction==droite){
  	motor[mDroit]=puissance*arriere;
  	motor[mGauche]=puissance*avant;
  	while (nMotorEncoder[mGauche]<nbDeg)
  		{}
  	motor[mDroit]=0;
  	motor[mGauche]=0;
	}

	if (direction==gauche){
  	motor[mDroit]=puissance*avant;
  	motor[mGauche]=puissance*arriere;
  	while (nMotorEncoder[mDroit]<nbDeg)
  		{}
  	motor[mDroit]=0;
  	motor[mGauche]=0;
	}
}


void avancerDistance(float distance,int puissance){
	float dist;
	dist=(distance*10*360)/(PI*DiamRoue);
	nMotorEncoder[mDroit]=0;
	motor[mDroit]=puissance;
  motor[mGauche]=puissance;
  while (nMotorEncoder[mDroit]<dist)
  	{}
	motor[mDroit]=0;
  motor[mGauche]=0;
}

void avancerJusquaLigne(int puissance ,int seuil){
  motor[mDroit]=puissance;
  motor[mGauche]=puissance;
  while(SensorValue(captLumi) > seuil)
  	{}
  motor[mDroit]=0;
  motor[mGauche]=0;
}

void avancerJusquaSeuilBlanc(int puissance ,int seuil){  		//sous prog pour avancer jusqu'au seuil blanc lorsque le robot est sur la ligne noire//
  motor[mDroit]=puissance;
  motor[mGauche]=puissance;
  while(SensorValue(captLumi) < seuil)
  	{}
  motor[mDroit]=0;
  motor[mGauche]=0;
}


int Choix_Ligne(){
	int ligne;
	nxtDisplayStringAt(10, 40, "Choix Ligne");
	while(SensorValue(tactileAv)==0){
		if (nNxtButtonPressed==kLeftButton){
			ligne=1;
			nxtDisplayStringAt(10, 40, "L1");

			}
		if (nNxtButtonPressed==kEnterButton){
			ligne=2;
			nxtDisplayStringAt(10, 40, "L2");

			}
		if (nNxtButtonPressed==kRightButton){
			ligne=3;
			nxtDisplayStringAt(10, 40, "L3");

			}
		}
	return(ligne);

}


void Avance_Compteligne(int Ligne,int seuil,int puissance){
	int nbL;
	bool vueBlanc;
	motor[mDroit]=puissance;
	motor[mGauche]=puissance;
	nbL=0;
	while (nbL<Ligne){
		if (SensorValue(captLumi)<seuil){
			if (vueBlanc){
				nbL=nbL+1;
				vueBlanc=false;
			}
		}
		else
			vueBlanc=true;
	}
	motor[mDroit]=0;
	motor[mGauche]=0;
}


float avance_percute_dist(int puissance){
	motor[mDroit]=puissance;
	motor[mGauche]=puissance;
	nMotorEncoder[mDroit]=0;//
	while(SensorValue(tactileAv)==0)
		{}
	motor[mDroit]=0;
	motor[mGauche]=0;
	return((nMotorEncoder[mDroit]*PI*DiamRoue)/360); 		//Renvoie la distance qu'il a parcourue pour recup la balle//
}



//------------------------Algo Principal----------------------//

task main(){
	int SeuilNoirBlanc;
	int SeuilBlancBleu;
	int Ligne;
	int dist_balle;
	SeuilBlancBleu=calculSeuil();
	wait1Msec(1000);
	SeuilNoirBlanc=calculSeuil();
	wait1Msec(2000);
	avancerJusquaLigne(-30,SeuilNoirBlanc);
	Ligne=Choix_Ligne();

	//choisir la ligne avec les boutons et confirmer avec le tactile avant//
	//repositionnement du robot//

	wait1Msec(2000);
	avancerDistance(36,20);
	wait1Msec(1000);
	tourner2roues(gauche,89,10);
	Avance_Compteligne(Ligne,SeuilNoirBlanc,20);
	avancerDistance(8.2,15);
	wait1Msec(1000);
	tourner2roues(droite,91.5,10);

	ouvrirPince(30,15);
	nMotorEncoder[mDroit]=0;
	dist_balle=avance_percute_dist(20);				//avance jusqu'a la balle et calcule la distance//
	fermerPince(30,13);

	avancerJusquaSeuilBlanc(10,SeuilNoirBlanc);
	avancerDistance(62,15);
	wait1Msec(1000);
	if (dist_balle<50){ 						//ici le 50 c'estpour les 50 cm et s'avoir s'il a recup la balle avant le point bleu//
		tourner2roues(droite,89.5,10);				// pour s'orienter en face de la Z1//
	}
	else {
		tourner2roues(gauche,89.5,10);				// pour s'orienter en face de la Z2//
		}

	avancerJusquaLigne(25,SeuilBlancBleu);  			// il est sense avancer jusqu' la ligne Bleu//
	ouvrirPince(30,8);                     				// il libere la balle//
}
